

## 1. 基本代码示例

```
#include <iostream>
using namespace std;

class Base {
public:
    virtual ~Base() {  // ✅ 虚析构函数
        cout << "Base destroyed" << endl;
    }
};

class Derived : public Base {
public:
    ~Derived() override {
        cout << "Derived destroyed" << endl;
    }
};

int main() {
    Base* obj = new Derived();  // 基类指针指向派生类对象
    delete obj;  // 关键调用
    return 0;
}
```

​**​输出结果：​**​

```
Derived destroyed
Base destroyed
```

## 2. 为什么是这个顺序？

### 2.1 析构函数的调用机制

​**​C++对象销毁的标准顺序：​**​

1. ​**​最派生类​**​的析构函数首先被调用
    
2. 然后按照​**​继承顺序的逆序​**​依次调用基类析构函数
    
3. 最后释放对象内存
    

### 2.2 虚函数表的作用

```
// 内存布局示例：
Derived对象:
[ vptr ] → 指向Derived的虚函数表
[ Base部分 ]
[ Derived特有成员 ]

// 虚函数表内容：
vtable for Derived:
[0] &Derived::~Derived()  // ✅ 派生类析构函数
[1] &Base::~Base()        // ✅ 基类析构函数
```

## 3. 详细的执行流程

### 3.1 `delete obj`时的具体步骤：

```
delete obj;  // 实际发生的操作：

// 1. 通过虚函数表查找正确的析构函数
//    obj->vptr[0] 指向 Derived::~Derived()

// 2. 调用 Derived::~Derived()
//    - 执行派生类的清理代码
//    - 输出 "Derived destroyed"

// 3. Derived析构函数执行完毕后，自动调用基类析构函数
//    - 这是C++的语言规范要求
//    - 输出 "Base destroyed"

// 4. 最后释放内存
```

### 3.2 对比非虚析构函数的情况

```
class Base {
public:
    ~Base() {  // ❌ 非虚析构函数
        cout << "Base destroyed" << endl;
    }
};

class Derived : public Base {
public:
    ~Derived() {
        cout << "Derived destroyed" << endl;
    }
};

int main() {
    Base* obj = new Derived();
    delete obj;  // 输出: "Base destroyed" (内存泄漏！)
    return 0;
}
```

​**​为什么不同？​**​

- 非虚析构函数：静态绑定，直接调用`Base::~Base()`
    
- 虚析构函数：动态绑定，通过vtable找到`Derived::~Derived()`
    

## 4. 底层汇编视角

### 近似等效的C++代码：

```
// delete obj 的实际等效操作：
void* actual_object = obj;  // 获取实际对象地址

// 1. 通过vtable查找析构函数
typedef void (*DestructorPtr)(void*);
DestructorPtr dtor = *(DestructorPtr*)(*(void**)actual_object);

// 2. 调用找到的析构函数（Derived版本）
dtor(actual_object);  // 输出 "Derived destroyed"

// 3. 析构函数内部会自动调用基类析构函数
```

## 5. 完整的对象生命周期

### 构造和析构的对称性：

```
class Derived : public Base {
    // 构造顺序：Base() → Derived()
    // 析构顺序：~Derived() → ~Base()
};

// 验证代码：
Derived* d = new Derived();
// 构造过程：
// 1. 分配内存
// 2. 调用 Base::Base()
// 3. 调用 Derived::Derived()

delete d;
// 析构过程：
// 1. 调用 Derived::~Derived()
// 2. 调用 Base::~Base()
// 3. 释放内存
```

## 6. 多重继承的情况

```
class Base1 {
public:
    virtual ~Base1() { cout << "Base1 destroyed" << endl; }
};

class Base2 {
public:
    virtual ~Base2() { cout << "Base2 destroyed" << endl; }
};

class Derived : public Base1, public Base2 {
public:
    ~Derived() override {
        cout << "Derived destroyed" << endl;
    }
};

int main() {
    Base1* obj = new Derived();
    delete obj;  // 输出顺序：
                 // Derived destroyed
                 // Base2 destroyed  (逆序)
                 // Base1 destroyed
    return 0;
}
```

## 7. 重要结论

### 为什么是 "Derived → Base" 顺序：

1. ​**​资源清理逻辑​**​：先清理派生类特有的资源，再清理基类资源
    
2. ​**​安全性​**​：避免在基类资源已释放后还访问派生类资源
    
3. ​**​语言规范​**​：C++标准明确规定的行为
    

### 实际应用意义：

```
class FileHandler {
public:
    virtual ~FileHandler() {
        if (file.is_open()) {
            file.close();  // 先关闭文件（基类资源）
        }
    }
};

class BufferedFileHandler : public FileHandler {
public:
    ~BufferedFileHandler() override {
        buffer.clear();  // 先清理缓冲区（派生类资源）
        // 然后自动调用基类析构函数关闭文件
    }
};
```

## 8. 记忆技巧

​**​构造​**​：从基础到具体（Base → Derived）

​**​析构​**​：从具体到基础（Derived → Base）

就像建房子和拆房子：

- 建房子：先打地基（Base），再建上层建筑（Derived）
    
- 拆房子：先拆上层建筑（Derived），再清理地基（Base）
    

这种顺序确保了资源管理的安全性和正确性。