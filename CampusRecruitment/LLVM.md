# 1.指令调度
指令调度是指对程序块或过程中的操作进行排序以有效利用处理器资源的任务。指令调度的目的就是通过重排指令，提高指令级并行性，使得程序在拥有指令流水线的CPU上更高效的运行。 DSP硬件拥有多级流水线，可通过实现编译器后端的指令调度器，重排指令，提高指令级并行性；减少在指令流水线中，为了解决数据型、结构型等风险而插入的Nop指令，减小代码体积，提高执行效率 

主要是实现了一个特定于DSP架构的指令调度器，首先我根据硬件属性完成了DSP的指令调度模型，其中主要**涉及每条指令的Latency和处理器资源**。DSP处理器支持VLIW特性，所以该调度器会在运行时根据当前的资源状态和指令依赖来动态的调度决策， （首先是初始化阶段，用于构建数据流图，和创建调度边界，初始化顶部和底部的就绪队列和待定队列，也是首先将出度和入度为0的节点加入到这些队列中去，然后就是整个调度循环的过程，picknode环节采用了创新的启发式算法来选择最佳节点，然后对这个节点进行调度，更新整个调度器的状态，包括调整就绪节点和一些寄存器状态） 
其采用了**双向调度策略**（即从一个调度单元的顶部和底部同时进行调度，这种策略有利于平衡指令并行性和寄存器压力，避免单向调度可能带来的局部最优问题，也就是在picknode阶段，算法会从顶部和底部的就绪队列中分别选择候选节点，并根据调度成本选择最佳节点）， 整个调度过程中保证了RegPressure动态跟踪（通过llvm的getMaxPressureDelta 方法计算每个候选节点的寄存器压力变化，然后存储在RegPressureTracker这个结构体中，如果出现Excess或CriticalMax较大，调度成本会相应增加，避免出现寄存器spill溢出）
其中最关键的部分是我为每个调度节点增加了一个**CostModel模型**，用来模拟该调度节点的成本，该调度成本如下所示：调度成本主要包括：寄存器压力、关键路径优先、资源可用性、阻塞节点数量等节点,包括寄存器压力、关键路径优先、资源可用性等
𝑪𝒐𝒔𝒕(𝑺𝑼) = 𝜶 + 𝑭𝒐𝒓𝒄𝒆(𝑺𝑼) + 𝑪𝒓𝒊𝒕𝑷𝒂𝒕𝒉(𝑺𝑼) + 𝑹𝒆𝒔𝑨𝒗𝒂𝒊𝒍(𝑺𝑼) + 𝑩𝒍𝒐𝒄𝒌𝑭𝒂𝒄𝒕𝒐𝒓(𝑺𝑼) + 𝒁𝒆𝒓𝒐𝑳𝒂𝒕(𝑺𝑼) − 𝑹𝒆𝒈𝑷𝒓𝒆𝒔𝒔(𝑺𝑼) − 𝑯𝒂𝒛𝒂𝒓𝒅(𝑺𝑼)
Force(SU) 则用来捕捉某些强制优先 的指令（例如标记了 isScheduleHigh 的指令）所带来的高优先级；
CritPath(SU) 结合了节点在指令依赖图中的高度或深度，以衡量其对关键路径的影响； 
ResAvail(SU) 通过检查指令能否在当前周期与已有指令并发发射来判断是否应 给出额外加分；BlockFactor(SU) 代表若调度该指令会立刻解锁一批后继或前驱 节点时所能带来的潜在收益；ZeroLat(SU) 用于评估零延迟依赖指令是否能与前 面 已 发 射 的 指 令 配 合 ， 若 可 以 则 给 出 适 当 的 激 励 ； 
RegPress(SU) 基 于 RegPressureTracker 的结果，当指令会显著推高高压寄存器集合占用时，就会减 分以避免溢出；
Hazard(SU) 则与流水线冲突或非零延迟依赖冲突相关，若当前 周期难以安全插入该指令，就应相应降低其得分。
# 2.自动向量化
总共定义了4路矢量单元（VP），每路包含640位矢量运算单元和16个640位矢量寄存器。可以通过矢量单元控制寄存器VPSEL来指示当前被激活的矢量单元
VPSEL的合法值包括：0x1、0x3、0x7、0xf

自动向量化是一类适用于向量处理器的编译优化，将多个标量指令合并为单个向量指令，实现数据级的并行计算，以优化应用的执行效率。
LLVM 的自动向量化分为两类：循环向量化与超字并行向量化（Superword-Level Parallelism, SLP）。循环向量化用于搜寻循环迭代间的向量化空间，超字并行向量化则对基本块内部的标量运算进行向量化分析。 
通过实现DSPTargetTransformInfo类并修改DSP编译器后端的数据布局，使得LLVM在进行向量化优化时，能够动态调整向量化因子（VF）。这个向量化因子表示在每个向量指令中可以同时处理的元素个数。这一优化的特殊之处在于，随着子目标（SubTarget）的变化，向量化因子也能灵活地调整。
本方法的目标是最大化向量化因子，以使Vectorizer能够达到最大的优化程度。 为了解决LLVM在Mem操作（Load/Store）的向量化过程中，对数据对齐（Alignment）的处理与目标架构的特定要求不匹配的问题，本文**引入了名为dsp-modify-vectorize-align的编译器后端优化pass**。 具体而言，LLVM输出的优化后的中间代码中，Mem操作的数据对齐通常是按照单个数据元素设定的。这与目标架构特有的VLoad/VStore指令的对齐要求（例如，VLoad要求数据按照256字节进行对齐）不相符。以int数据为例，如果生成的矢量的Load操作按照4字节对齐，就可能导致数据异常加载，从而在后端指令选择期间引发错误，并最终导致生成的代码被标量化。通过引入dsp-modify-vectorize-align优化pass，我们能够有效处理这种情况，确保矢量的Load/Store操作的数据对齐与目标架构一致，从而提高向量化优化的正确性和效果。

# 3.硬件循环+软流水
[[hardware loop.pdf]]
核心目标是​**​消除控制流开销、最大化硬件并行性​**
1. 硬件循环
	1. 基于VECTOR DSP的专用`LOOP`指令，通过硬件寄存器（`StartLoop`/`EndLoop`/`LoopCount`）实现循环迭代的自动化控制，完全消除传统循环中条件判断、跳转指令及延迟槽的开销
	2. loop指令可实现动态绑定循环体起始/结束地址，硬件自动检测迭代终止条件，单条指令覆盖初始化、计数和跳转逻辑
	3. **针对循环内部复杂分支**（如条件提前退出），创新性引入​**​Landing Block机制​**​，动态重定向跳转目标至闭合块（Latch Block）前驱，确保硬件循环控制流与软件逻辑的一致性
2. 软件流水线优化：VLIW架构适配​
	1. 调度器核心：SwingSchedulerDAG
	2. 采用 **Swing Modulo Scheduling（SMS） 算法**，该算法尝试在不同迭代间重叠指令执行（interleaving），以提升循环体内部的并行度，同时考虑寄存器压力
		1. 构建数据流图DDG
		2. 计算最小启动间隔MII
			1. **ResMII（Resource-Bound MII）​**​：由硬件资源（如功能单元数量）限制决定的下界
			2. **RecMII（Recurrence-Bound MII）​**​：由循环内所有​**​依赖环路（Recurrence Circuit）​**​ 中延迟总和决定的下界
		3. 生成Prolog、Kernel、Epilog

# 4.Tablegen、寄存器描述
​[LLVM后端探究-寄存器定义篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/652571606)

# 5. 外设兼容
识别actionbit，插桩

# 6.LLVM其他知识
## 6.1 LLVM IR
1: 有了LLVM这层IR的存在，其上的大量工作就可能被复用，将之前的O(MxN)的行业复杂度降阶为O(M+N)的行业复杂度，这里M指语言前端数量，N指硬件后端数量。 
2: SSA 静态单赋值 （static single assignment） 要求每个变量在程序中只能被赋值一次，这个特性使得在编译器进行各种优化时变得更加高效和简洁。 SSA形式使得使用 use-def链 变得清晰，对于每个变量的使用，编译器可以直接知道其唯一的定义位置，这简化了数据流分析和优化。 静态单赋值，这个静态 可以理解为SSA形式在编译时确定的，变量的赋值和使用关系在编译阶段被分析并固定下来。
3：Phi 节点： 实现SSA的关键元素，他们用于处理控制流中变量赋值问题，确保在不同的控制流路径中能够正确地选择变量的值。 Phi 节点的选择机制依赖于CFG的结构，当程序执行到某个基本块时，phi结点会根据前一个基本块的标签（label）来决定使用哪个值。 Phi节点 主要解决了在多个控制流路径中变量值的不确定性 确保每个变量在不同的执行路径中能够正确地选择其值。 
4: mem2reg 优化： mem2reg pass会识别出只有load和store指令使用的alloca指令,并将其提升为SSA形式。 它会在控制流图的适当位置插入phi节点,并进行变量重命名,将内存访问优化为寄存器访问。 这样可以避免频繁的内存加载和存储,提高程序性能
## 6.2 JIT编译
JIT（Just-In-Time）编译是一种动态编译技术，允许程序在运行时将中间代码（如字节码）编译成机器代码。JIT编译器在程序执行过程中，根据实际的运行情况进行代码优化，从而提高程序的执行效率。它在许多现代编程语言和运行时环境中得到了广泛应用，例如Java虚拟机（JVM）和.NET的公共语言运行时（CLR）。 
**JIT编译的工作原理** 
字节码执行：当程序启动时，首先执行的是字节码。字节码是一种中间表示，具有平台无关性。 
动态编译：在程序运行过程中，JIT编译器会监控代码的执行情况，识别出频繁调用的代码路径（热路径），并将这些代码编译为本地机器代码。 
缓存已编译代码：编译后的机器代码会被缓存，以便后续调用时直接使用，避免重复编译，从而提高执行效率。 
运行时优化：由于JIT编译是在运行时进行的，编译器可以利用运行时信息（如数据类型、调用频率等）来进行更有效的优化。
## 6.3 llvm和dsp
编译器是实现计算机高级语言向低级语言转换的基本工具。 LLVM 是目前最流行的模块化的、可重定向的编译框架，LLVM扩展了GCC的三段式编译器架构 （前端（词法分析，语法分析，将代码转换成抽象语法树），优化器，后端） 前端负责解析高级语言代码，后端基于处理器的底层信息生成相应的机器代码，为此 LLVM 专门设计了 IR 语言作为前端后端之间的中间表示。LLVM IR使得LLVM　可以支持多种源语言和多种目标架构，LLVM　IR是目标无关的，所以中端基于IR的优化可以变得更高效和通用 且基于SSA，有助于数据流分析和优化。 
DSP数字信号处理器，主要用于实时处理数字信号，这是专用的微处理器，转为高效的执行数字信号处理任务（音频、通信等信号处理滤波、变化等） 满足低功耗和实时计算的需求，非常适合嵌入式系统
# 7.[[git]]常用命令




