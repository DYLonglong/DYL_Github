# 1 硬件循环和软流水 123
LOOP指令主要有两个参数，第一个参数是循环迭代次数，第二个参数是循环体的相对PC的结束地址。通过LOOP可以获得循环执行前的相关信息，从而进行有效的循环展开控制，节省了每次循环迭代变量计算、比较指令、分支跳转指令以及分支延迟槽带来的额外的指令执行的时间

loop GR Addr。第一个操作数是通用寄存器，用于保存循环的迭代次数，第二个操作数是地址标签，表示循环体的相对结束地址，即相对于 LOOP 指令的 PC 值的偏移

硬件循环在IF2阶段添加了三个控制寄存器：
loopStart: 循环的起始地址。
loopCount: 循环计数。
loopEnd: 循环结束地址。
当执行LOOP指令时，EX阶段会通过其参数计算出这三个寄存器的值，并将其传递到IF2阶段。IF2阶段在每次提取一条VLIW指令包并递增程序计数器（PC）后，会检查当前PC值是否达到loopEnd。如果达到，则递减loopCount，并判断是否小于0。如果小于0，则循环结束；否则，IF1阶段的fetchAddr寄存器会重置为loopStart，从而确保下一周期提取循环体的第一条指令

原本循环控制的空指令延时槽、分支指令、比较指令和归纳变量自增/减等指令可以被取代

**技术内容**
1、前置块（Preheader Block）：在循环开始之前执行的块，用于初始化循环变量并将控制流导向循环头块。前置块也为循环不变代码的外提优化提供了一个放置位置。
 2、循环头块（Header Block）：循环的起始基本块，包含循环条件判断。根据条件的真假，将控制流导向循环体块或跳转至出口块。循环头块在 LLVM 中也是循环识别的入口标识。
 3、循环体块（Body Block）：循环中需要重复执行的指令集合，包含实际的计算逻辑或操作。在复杂循环中，循环体块可以由多个基本块组成。
 4、闭合块（Latch Block）：用于更新循环计数变量，并将控制流返回循环头块以重新检查条件。Latch 块的末尾通常包含一个跳转指令，决定是否继续循环或跳出循环。
 5、出口块（Exit Block）：循环条件不满足时执行的块，用于处理循环完成后的逻辑。出口块接收从循环头块或 Latch 块跳出的控制流。
通过分析和处理循环中的 Preheader、Header 和 Latch 块，在编译过程中实现相应的硬件循环指令的生成。

硬件循环仅能应用于**静态循环和半静态循环**，这是因为 LOOP 指令要求在进入循环前预先确定循环的迭代次数，以便硬件能有效控制循环的执行流程
1、静态循环：静态循环的迭代次数在编译时就已固定，不会受运行时的条件或外部数据影响。这种循环的执行次数可以通过编译器的静态分析直接确定，从而便于优化。
2、半静态循环：半静态循环的迭代次数虽然在编译阶段不是一个立即数，但在运行时的某个稳定阶段被解析，即在开始执行循环体前可确定下来。

再**计算迭代次数**

编译器首先会检查循环结构中是否已有 Preheader 块，若不存在则创建一个新的 Preheader 基本块，并将其插入在循环的 Header 块之前。为了正确维护控制流图（Control Flow Graph, CFG），编译器会将所有原本指向 Header 的前驱节点重新指向新建的 Preheader 块。通过这种方式，CFG 中的控制流会被重新调整，使 Preheader 成为循环的唯一入口节点，从而保持流图的连贯性和分析准确性。在完成 CFG 的更新后，编译器会在 Preheader 块末尾插入适用于 VECTOR DSP 的硬件循环 LOOP 指令。如果循环为静态循环，编译器会使用 movigh 和 movigl 指令将迭代次数的立即数传入相应寄存器，设置LOOP 指令的循环计数。而对于半静态循环，则需在 LOOP 指令前加入额外的计算步骤来确定循环迭代次数，再将其传入寄存器。LOOP 指令的第二个参数，即循环结束地址相对于 LOOP 指令 PC 的偏移，则暂时设定为 Latch 块的标签。

接下来，为了确保在超长指令字（VLIW）绑定后，编译器仍然能够定位到循环的结束地址以更新 LOOP指令的偏移字段，我们在循环体的末尾基本块插入了一个定义为伪指令的 ENDLOOP 指令。伪指令不会直接执行，但在编译期间为 CFG 提供了标记和控制流优化的参考。编译器会将原有的 Latch 块拆分，形成新的循环体尾部基本块，仅包含 ENDLOOP 指令作为新的 Latch 块，并在 CFG 中将此基本块设置为出口节点，即 LOOP 指令的第二个参数。此调整确保了 CFG 的完整性，并为后续指令调度和循环优化提供了结构化支持。在 VECTOR DSP 处理器中，流水线的运行效率和硬件循环机制的稳定性是实现高效计算的重要保证。VECTOR DSP 流水线在指令取指阶段分为 IF1 和 IF2 两个阶段，分别处理指令的地址获取和指令数据的准备。在 IF2 级的后半段，硬件循环机制会持续监测程序计数器（PC 寄存器）递增后的值，判断其是否与硬件循环控制寄存器 loopEnd 中的值相等，从而判定当前循环是否已经到达设定的边界条件。当循环体内的倒数第二条指令到达 IF2 级处理时，PC 寄存器会再次自增，指向循环体的最后一条指令地址，这也正好满足硬件循环的触底条件。这一触底条件标志着该轮循环即将结束。在满足该条件时，流水线机制会将循环起始地址 loopStart 传递至 IF1 级中的取指地址寄存器 fetchAddr，确保下次从流水线取出的指令是循环体的第一条指令，从而顺利进入下一个循环迭代。然而，复杂情况出现在当循环体内部包含分支指令（如条件跳转）时，且该分支的跳转目标恰好为循环体的最后一条指令地址。此时，若分支条件满足并提前跳转至循环体的末尾，当前循环将提前结束。这导致倒数第二条指令将不会进入 IF2 级处理，从而没有触发预期的硬件循环触底条件，使 VECTOR DSP硬件循环机制失效。为了避免这种情况的发生，编译器在设置循环结束地址时，还需要额外检查循环体中是否存在分支指令的跳转目标为 loopEnd 地址的情况。如果检测到这种特殊的循环内部分支情况，编译器会生成一个名为 Landing 的新基本块，这个基本块仅包含一条空指令（nop），用于占位。随后，编译器将 Landing块插入到循环的结束点 Latch 块之前，并将原本跳转至 Latch 块的所有分支指令重新指向 Landing 块，从而避免提前结束循环的情况。尽管这样的处理方案使得每次循环体迭代的执行时间增加了一个流水段周期，因多消耗了一个指令周期去执行 nop 指令，但这种特殊的内部分支情况在实际算法中并不常见。同时，由于硬件循环机制通过消除迭代变量的计算、比较指令以及控制循环的跳转指令，大幅降低了每次循环迭代所需要的指令开销，因此总体上循环体的执行效率仍然会得到有效提升。这一修改策略使得 VECTOR DSP 的硬件循环机制在应对复杂的控制流情况时依然保持了稳定性和高效性

# 2 全局代码调度
首先介绍一下基本块的概念，基本块是程序中最大限度顺序执行的语句序列，其中只有一个入口和出口，入口是其第一个语句，出口是其最后一个语句；简单来说就是**分支语句后面的部分，和循环主体部分**。局部调度就是在基本块里面调度代码，而**全局代码调度（Global Code Scheduling）就是跨基本块进行调度，**软件流水就是一个典型例子。前面提到，循环已经能够得到很好的优化了（软件流水+循环展开），而非循环的分支（if-then-else）还没有很好的优化方法。

全局代码调度是一个很复杂的过程，需要考量诸多细节因素，为了简化这个过程，已经开发了几种不同的全局代码调度方法。我们在这里简要探讨的两种方法：**踪迹调度 Trace Scheduling+超级块 Superblocks**。它们都依赖于一个简单的原则：**将编译器的注意力集中在直线代码段上，该代码段表示估计最频繁执行的代码路径**。展开可以产生直线代码，但是如何处理条件分支是个很大的问题，可以通过选择和调度最频繁的路径来有效地拉直它们。

#### 踪迹调度 (Trace Scheduling) 

1. **路径选择（Trace Selection）：**
   - 通过分析程序的控制流图 (CFG) 和执行频率，选择最有可能频繁执行的路径。
   - 例如，使用动态分析数据，选出执行次数最多的一条路径。

2. **路径合并（Trace Formation）：**
   - 选择的路径形成一个连续的踪迹。
   - 确保所选路径上的基本块按照执行顺序依次排列。

3. **路径调度（Trace Scheduling）：**
   - 对合并后的踪迹进行重新排序，优化指令调度。
   - 优化目标包括减少流水线停顿（如消除数据依赖）、提高指令级并行（如利用空闲周期）。

4. **路径修复（Trace Fix-up）：**
   - 处理在路径外的控制流和数据依赖。
   - 插入必要的跳转指令，确保程序正确性。

#### 超级块 (Superblocks)

1. **超级块形成（Superblock Formation）：**
   - 识别程序中热点路径，并提取相关的基本块形成超级块。
   - 确保超级块只有一个入口，允许多个出口。

2. **超级块优化（Superblock Optimization）：**
   - 对超级块内的指令进行重排和优化。
   - 消除冗余指令、优化寄存器分配等。

3. **分支处理（Branch Handling）：**
   - 确保超级块内的多个出口正确处理。
   - 通过插入补丁代码或调整跳转指令来处理分支。

4. **生成机器代码（Code Generation）：**
   - 将优化后的超级块转换为目标机器代码。
   - 确保生成代码的正确性和高效性。
# 3 LLVM-mca
```
Iterations：分析中模拟的迭代次数。
Instructions：总指令数。
Total Cycles：执行所有指令所需的总周期数。
Dispatch Width：处理器每周期可以调度的最大指令数。
uOps Per Cycle：每周期执行的微操作数。
IPC：每周期执行的指令数（Instructions Per Cycle）。
Resources：显示处理器资源的使用情况，包括微操作数和端口使用情况等。
Block RThroughput：基本块的平均吞吐量。
Load Ports：这个百分比表示加载端口（Load Ports）的使用情况。加载端口是处理器用来从内存中读取数据的资源。66%的使用率意味着在模拟的执行过程中，这些端口有66%的时间处于被占用状态。

ALU Ports：这个百分比表示算术逻辑单元端口（ALU Ports）的使用情况。算术逻辑单元是处理器用来执行数学计算和逻辑操作的资源。33%的使用率意味着在模拟的执行过程中，这些端口有33%的时间处于被占用状态。
```
**功能和特点**
1. **指令调度模拟**：
   - 模拟指令在处理器流水线中的调度和执行。
   - 评估指令之间的依赖关系和资源冲突。
   **指令描述**：定义指令的延迟和资源使用（位于 `Target/Xxx/XxxInstrInfo.td`）**调度模型**：为目标 CPU 定义一个调度模型（位于`Target/Xxx/XxxSchedule.td`
实际的优化模型优化出来的程序，在实际的DSP芯片上运行时，我们只能看到整个程序的运行cycle，无法去方便的分析到底是哪里产生冲突等导致流水线stall，通过该工具出示的

2. **性能分析**：
   - 预测指令的吞吐量和延迟。
   - 识别潜在的性能瓶颈，如数据依赖和资源冲突。
   - 分析指令的执行周期，估计整个代码段的执行时间。

3. **微架构模型**：
   - 基于 LLVM 后端的微架构描述，模拟特定处理器的行为。
   - 支持多种处理器架构，如 x86、ARM、AArch64 等。

4. **详细的统计信息**：
   - 提供丰富的统计信息，如每周期的指令数、吞吐量、资源利用率等。
   - 帮助开发者了解处理器资源的使用情况和性能瓶颈。

5. **集成性**：
   - 与 LLVM 编译器无缝集成，可以直接分析由 LLVM 生成的目标代码。
   - 支持从汇编代码或机器代码输入，灵活性高。

**时间线视图**
1. [x,x]第一个索引标识迭代，第二个索引是指令索引（即它在代码序列中的位置）,这是三次迭代
2. 从上面的示例输出中，我们知道以下内容
	- 指令 [1,0] 在周期 1 被调度。
	    
	- 指令 [1,0] 在周期 2 开始执行。
	    
	- 指令 [1,0] 在周期 4 达到回写阶段。
	    
	- 指令 [1,0] 在周期 10 退休。
